
def ex1():
    print("1-я тема характеризуется, как: \n— задания базового уровня сложности,\n— требуется использование специализированного программного обеспечения — нет,\n— время выполнения – примерно 3 минуты,/n— максимальный балл — 1\n \nПроверяемые элементы содержания: Умение представлять и считывать данные в разных типах информационных моделей (схемы, карты, таблицы, графики и формулы)")
    print("Это устная задача, так что могу только показать как ее реашть...")
    print("Для решения задачи используем построение дерева с подсчетом значений для каждой ветви (протяженности дорог).\nПри движении от корня дерева (А) вниз будем иметь в виду, что:\nрассматривать вершины, которые уже есть в текущей «ветви», — не нужно,\nесли получаемое число (суммарная протяженность дорог) превышает какое-либо из найденных вариантов от A до F, \nто дальше эту ветвь можно не рассматривать.")
    exes_exes1 = int(input("если это не та версия задачи то нажмите 1 \n Если это решение вам помогло нажмите 2"))
    if exes_exes1 == 1:
        print("Задача (Редкий вариант, но возможный ) \nМежду населёнными пунктами А, B, С, D, E, F построены дороги, протяжённости которых приведена в таблице. \n (Отсутствие числа в таблице означает, что прямой дороги между пунктами нет.)")
        print("Расставим точки А, B, С, D, E, F по кругу.")
        print("Теперь в соответствии с таблицей соединим эти города, указав числа возле линий.\n Стараемся сделать рисунок, как можно более понятным, избегаем, \n по возможности, пересечений, применяем разные цвета.")
        print("Получилась наглядная карта городов. Оценив все пути от пункта A до пункта F.")
def ex2():
    print("2-е задание: «Таблицы истинности»\nУровень сложности — базовый,\nТребуется использование специализированного программного обеспечения — нет,\nМаксимальный балл — 1,\nПримерное время выполнения — 3 минуты.\n  \nПроверяемые элементы содержания: Умение строить таблицы истинности и логические схемы\nЭто устная зхадача так что могу лишь сказать как ее решать, и дать таблицу истинности))\nшаблон:\nПример: Миша заполнял таблицу истинности логической функции F\n¬(y → (x ≡ w)) ∧ (z → x)\n но успел заполнить лишь фрагмент из трёх различных её строк, даже не указав, какому столбцу таблицы соответствует каждая из переменных w, x, y, z.\n таблица, где q= пусто:\n q 1 1 q 1\n 0 q q 0 1 \n q 0 1 0 1 \n Определите, какому столбцу таблицы соответствует каждая из переменных w, x, y, z \n В ответе напишите буквы w, x, y, z в том порядке, в котором идут соответствующие им столбцы \n(сначала буква, соответствующая первому столбцу; затем буква, соответствующая второму столбцу, и т.д.). \nБуквы в ответе пишите подряд, никаких разделителей между буквами ставить не нужно.\nx y z w\nЗдесь мы перебираем все варианты с помощью вложенных циклов. \nИ если наша функция превращается в истину, то печатаем значения переменных\nОтрицание меняется на not, следование представляем по формуле A->B = ¬A or B.\nТ.к. у нас нет столбца, который состоит только из одних нулей, то в четвёртом столбце в пустой ячейке будет 1.\nПолучилась строчка из трёх 1. Значит, в первом столбце в пустой ячейке вверху будет 0. Следовательно, первый столбец - w.\nПоследний столбец достаётся z, т.к. из оставшихся переменных только у неё два 0 и одна 1. Второй столбец, по принципу исключения, - это x.\nОтвет: wxyz")
def ex3():
    print("Задание 3\nВ файле приведён фрагмент базы данных «Продукты» о поставках товаров в магазины районов города. База данных состоит из трёх таблиц.\nТаблица «Движение товаров» содержит записи о поставках товаров в магазины в течение первой декады июня 2021 г., \nа также информацию о проданных товарах. Поле Тип операции содержит значение Поступление или Продажа, а в соответствующее \nполе Количество упаковок, шт. занесена информация о том, сколько упаковок\n товара поступило в магазин или было продано в течение дня.\n Заголовок таблицы имеет следующий вид.")
    print("ID  операции\ Дата \ IDмагазина \ Артикул \ Типоперации \ Количествоупаковок,шт. \ Цена,руб./шт.")
    print("Таблица «Товар» содержит информацию об основных характеристиках каждого товара. Заголовок таблицы имеет следующий вид.")
    print("Артикул	\ Отдел \ Наименование	Ед.  изм. \ Количество в упаковке	\ Поставщик")
    print("Таблица «Магазин» содержит информацию о местонахождении магазинов. Заголовок таблицы имеет следующий вид")
    print(" ID Магазина \ Район \ Адрес")
    print("Используя информацию из приведённой базы данных, определите на сколько увеличилось количество упаковок яиц диетических, \nимеющихся в наличии в магазинах Заречного района, \nза период с 1 по 10 июня включительно.В ответе запишите только число.")
    print("Откроем файл Excel. Внизу у нас три вкладки (три таблицы).\nЕсть магазины, есть товары, есть операции, какие товары, куда перемещаются.\nПрочитаем ещё раз внимательно вопрос задачи. Переходим на вкладку Магазин. Выделим столбец 'Район' и отсортируем по данному столбцу таблицу (кнопка сортировки находится обычно в правом верхнем углу). Если появится вопрос об автоматическом расширении выделенного диапазона, отвечаем утвердительно.\nТеперь удобно посмотреть ID магазинов Заречного Района. Всего получается 4 ID: M3, M9, M11, M14.")
    print("Переходим на вкладку Товар. Нас интересует яйцо диетическое. Ищем по поиску (Ctrl + F) и получаем Артикул данного товара. Это номер 15.\nДанные мы собрали, теперь переходим на вкладку Движение товаров.\nСначала подсчитаем сколько поступило указанного товара в указанные торговые точки за период 1-10 июня. \nУбедимся, что первая строчка не подходит нам по условию и в ячейке H2 ставим значение 0.\n Это число олицетворяет количество поступивших товаров.\nВ ячейке H3 пропишем формулу:")
    print('=ЕСЛИ(И(ИЛИ(C3="M3";C3="M9";C3="M11"; C3="M14"); D3=15; F3="Поступление");H2+E3;H2)')
    print("Эту формулу мы распространяем на весь столбец H. Тогда она будет анализировать каждую строчку\n и подсчитывать количество поступившего товара, учитывая все обстоятельства задачи.\n В самой последней ячейке столбца H получается число 1420.\n Это и есть то количество нашего товара, которое поступило в указанные торговые точки.\n Про дату в этой задаче думать не нужно, т.к. вся таблица по операциям происходит в пределах 1-10 июня.\nАналогично, подсчитаем в столбце I, какое количество убыло. Тогда формула получается:")
    print('=ЕСЛИ(И(ИЛИ(C3="M3";C3="M9";C3="M11"; C3="M14"); D3=15; F3="Продажа");I2+E3;I2)\nПолучаем количество проданных товаров 454.\Подсчитаем на сколько же увеличилось товаров: \n 1420-454=966 \nЭто и будет ответ.')
def ex4():
    print("Задание 4\nДля кодирования некоторой последовательности, состоящей из букв Л, М, Н, П, Р, решили использовать неравномерный двоичный код, \nудовлетворяющий условию, что никакое кодовое слово не является\n началом другого кодового слова. Это условие обеспечивает возможность\n однозначной расшифровки закодированных сообщений. Для букв Л, М, Н использовали соответственно \nкодовые слова 00, 01, 11. Для двух оставшихся букв П и Р кодовые слова неизвестны.\nУкажите кратчайшее возможное кодовое слово для буквы П, при котором код будет удовлетворять \nуказанному условию. Если таких кодов несколько, укажите код с наименьшим числовым значением.")
    print("Т.к. никакое кодовое слово не является началом другого кодового слова, то, значит, выполняется условие Фано.\nСледовательно, можно воспользоваться приёмом дерево Фано.\nРазместим буквы для которых известны коды на дереве Фано.")
    print("При построении дерева Фано мы проращивает от корня две ветки 0 и 1. От каждой ветки тоже можно прорастить\n две ветки 0 и 1 и т.д. Если буква 'села' на ветку, то она блокирует эту ветку,\n и больше нельзя проращивать новые ответвления от неё.\nУ нас остались две буквы П и Р, а прорастить можем только одну ветку (из 1 - прорастить 0). Мы проращиваем эту ветку и от неё проращиваем два ответвления, \nи теперь мы уже можем разместить оставшиеся буквы на дереве.")
    print("Для П выбираем код с меньшим числовым значением - 100, как написано в условии. Букве Р достаётся код - 101")
def ex5():
    print("На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.\n1. Строится двоичная запись числа N.\n2. К этой записи дописываются справа ещё два разряда по следующему правилу:\nа) складываются все цифры двоичной записи числа N, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;\nб) над этой записью производятся те же действия – справа дописывается остаток от деления суммы её цифр на 2.\nПолученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью результирующего числа R.\nУкажите такое наименьшее число N, для которого результат работы данного алгоритма больше числа 77. В ответе это число запишите в десятичной системе счисления.")
    print("На вход поступает натуральное (обычное, не дробное, положительное) число N.\nЭто число алгоритм переводит в двоичную систему.\nСказано, что дописываются два разряда справа к тому двоичному числу, которое получили в первом пункте.")
    print("Про первый дополнительный разряд написано в пункте a второго правила:\n 'складываются все цифры двоичной записи числа N, и остаток от деления суммы на 2 дописывается в конец числа (справа).\n Например, запись 11100 преобразуется в запись 111001'.\nЕсли сказать более просто, то автомат подсчитывает количество единиц у первоначального двоичного числа N,\nполученного в первом пункте. Если количество чётное, то автомат в первый дополнительный разряд должен поставить 0. Если количество нечётное, \nто автомат в первый дополнительный разряд должен поставить 1.\nПро второй дополнительный разряд сказано в пункте б второго правила. Автомат сделает тоже самое, что и в предыдущем пункте,\n только теперь подсчёт единиц будет происходить не только в двоичной записи числа N,\n но и в первом дополнительном разряде.\nВ вопросе просят указать входящее наименьшее число N, чтобы автомат выдал число R больше 77.\nТ.к. число R должно быть больше 77, то переведём число 78 (77 + 1) в двоичный вид, чтобы можно было оценить входящее число N.\nЭто можно сделать стандартным калькулятором windows, переключив его в режим 'Программиста' (Вид->'Программист').\nПолучилось число 1001110. Будем рассматривать (начиная с 1001110) числа на выполнение правил,\n которые заданы для алгоритма. Если все правила будут выполнены, значит, мы получили то число,\n по которому вычислим изначальное N. Нам нужно получить именно минимальное число,\n поэтому мы и начали с минимального возможного претендента для числа R (78).")
    print("Здесь нам сразу повезло, сразу число 78 удовлетворяет всем условиям. Нас просили написать именно число N,\n поэтому от числа 1001110 отбрасываем два разряда и переводим в десятичную систему.\nПереводим в десятичную систему 10011 -> 19.\nОтвет: 19")
def ex6():
    print("Задание 6\nОпределите, при каком наибольшем введённом значении переменной s программа выведет число 64.\n Для Вашего удобства программа представлена на четырёх языках программирования.")
    print("На python выглдяит так: s = int(input())\ns = s // 10\nn = 1\nwhile s < 51:\ns = s + 5\nn = n * 2\nprint(n)")
    print("Решим задачу методом перебора на языке программирования Python.\nНас спрашивают, какое наибольшее число должен ввести пользователь программы, чтобы программа распечатала число 64. \nМы будем подставлять каждое число в диапазоне, к примеру, от 1 до 1000 и попробуем получить на выходе число 64.")
    print("for i in range(1, 1000):\ns = i\ns = s // 10\nn = 1\nwhile s < 51:\n    s = s + 5\n    n = n * 2\nif n==64: print(i)")
    print("Делаем это с помощью цикла. Как только в переменной n будет значение 64, мы печатаем переменную i")
    print("...\n251\n252\n253\n254\n255\n256\n257\n258\n259")
    print("Видим, что максимальное число, которое даёт нужный результат это 259.\nОтвет: 259.")
def ex7():
    print("Задание 7 \n Для хранения произвольного растрового изображения размером 128 × 320 пикселей отведено 20 Кбайт памяти без учёта размера заголовка файла.\n Для кодирования цвета каждого пикселя используется одинаковое количество бит, коды пикселей записываются в файл один за другим без промежутков.\n Какое максимальное количество цветов можно использовать в изображении?")
    print("Узнаем, сколько информации будет весить один пиксель (одна точка).")
    print("вес 1 пикселя = 20кб / 128 * 320 = 160бит/40 = 4 целых бита")
    print("Теперь воспользуемся главной формулой для 7 задания из ЕГЭ по информатике.\n N(количество цветов) = 2**i(количество бит в одном пикселе)")
    print("N=2**4=16 цветов")
def ex8():
    print("Задание 8\nВсе четырёхбуквенные слова, в составе которых могут быть только буквы Л, Е, М, У, Р, записаны в алфавитном порядке и пронумерованы, начиная с 1.\nНиже приведено начало списка.\n1. ЕЕЕЕ\n2. ЕЕЕЛ\n3. ЕЕЕМ\n4. ЕЕЕР\n5. ЕЕЕУ\n6. ЕЕЛЕ\n…\nПод каким номером в списке идёт первое слово, которое начинается с буквы Л?")
    print("Закодируем в правом столбце буквы цифрами, начиная с нуля \nДальше кодирование прекращаем, т.к. буквы начинают повторяться.\nЕсли представить список в виде цифр, то получится счёт в пятеричной системе, ведь у нас пять цифр.")
    print("1. 0000\n2. 0001\n3. 0002\n4. 0003\n5. 0004\n6. 0010 \nВ вопросе спрашивают про первое слово, которое начинается с буквы Л. А мы понимаем,\n что спрашивают про число 10005 в пятеричной системе, потому что это первое число, которое начинается\n с 1. Длина числа равна 4, т.к. длина слов равна 4.\nПереведём число 10005 из пятеричной системы в нашу родную десятичную систему.\n0*50 + 0*51 + 0*52 + 1*53 = 125\nА порядковый номер (столбец слева) отличается от счёта в пятеричной системе на 1. Порядковый номер на 1 больше. Поэтому в ответе напишем 126.\nОтвет: 126")
def ex9():
    print("Задание 9\n Откройте файл электронной таблицы, содержащей в каждой строке три натуральных числа. Выясните, какое количество троек\n чисел может являться сторонами треугольника, то есть \nудовлетворяет неравенству треугольника.\nВ ответе запишите только число.")
    print("Неравенство треугольника заключается в том, что каждая сторона должна быть меньше, чем сумма двух других сторон.\nНапротив тех строчек, которые удовлетворяют этому неравенству будем ставить 1, остальным ставим 0.\nСформируем формулу для первой строчки. Кликаем в ячейку D1 и нажимаем кнопку Вставить функцию")
    print("ыбираем функцию ЕСЛИ. Пишем логическое выражение:\nИ(A1<B1+C1; B1<A1+C1; C1<A1+B1)\nВ Значение_если_истина ставим 1. В Значение_если_ложь ставим 0.")
    print("Если одновременно выполняются три условия, то в ячейку идёт 1, иначе 0.\nРаспространим формулу на весь столбец. Подведём курсор к правому нижнему углу. Как только загорелся \nчёрный крестик, кликаем два раза, и формула должна распространится на весь столбец.\nВозле тех строчек, которые удовлетворяют условию, будут нули, возле тех, которые нет, будут единицы.\nНайдём сумму столбца D. Это и будет количество троек, которые подходят в нашей задаче.\nКликаем по ячейке E1, нажимаем Вставить функцию и выбираем функцию СУММ. Там выбираем столбец D мышкой.")
    print("Нажимаем ОК, получается 2453.\nОтвет: 2453")
def ex10():
    print("Задание 10\n С помощью текстового редактора определите, сколько раз, не считая сносок, встречается слово «долг» или «Долг»\n в тексте романа в стихах А.С. Пушкина «Евгений Онегин». Другие формы слова «долг»,\n такие как «долги», «долгами» и т.д., учитывать не следует. В ответе укажите только число.")
    print('Открываем соответствующий файл в программе Word. На вкладке "Главная" находится кнопка "Найти".\n Кликаем по чёрному треугольнику возле этой кнопки и выбираем "Расширенный поиск".\nНа вкладке "Главная" находится кнопка "Найти". Кликаем по чёрному треугольнику возле этой кнопки и выбираем "Расширенный поиск".')
    print('Далее, нажимаем кнопку "Больше>>".\nТеперь у нас есть все инструменты, чтобы решить 10 задание из ЕГЭ по информатике 2022.\nВ поле "Найти" пишем наше слово "долг". Галочку "Учитывать регистр" не ставим, т.к. слово может быть и с большой буквы. Но ставим галочку "Только слово целом".\nНажимаем Найти в -> "Основной документ".')
    print("Ответ: 1")
def ex11():
    print("Задание 11\n При регистрации в компьютерной системе каждому объекту сопоставляется идентификатор, состоящий из 15 символов и \nсодержащий только символы из 8-символьного набора: А, В, C, D, Е, F, G, H. В базе данных для хранения сведений о каждом объекте\n отведено одинаковое и минимально возможное целое число байт. При этом используют посимвольное кодирование идентификаторов,\n все символы кодируют одинаковым и минимально возможным количеством бит. Кроме собственно идентификатора,\n для каждого объекта в системе хранятся дополнительные сведения, для чего отведено 24 байта на один объект.\nОпределите объём памяти (в байтах), необходимый для хранения сведений о 20 объектах.\n В ответе запишите только целое число – количество байт")
    print("Теперь нужно определить: сколько бит занимает одна ячейка (1 символ идентификатора!).\nКогда речь идёт о количестве бит, применяем формулу, которую мы использовали в 7 задании из ЕГЭ по информатике.\n Там мы кодировали цвета для одного пикселя, \nа здесь нужно закодировать 8 букв для одного поля идентификатора.")
    print("Применяем:\nN = 2**i = 8\nСледовательно, для кодирования одного поля идентификатора потребуется 3 бита.\nДля всего идентификатора потребуется 3 * 15 = 45 бит.\n Т.к. используется целое число байт для хранения идентификатора,\n то в байтах идентификатор будет весить 6 байт (45/8 = 5,625).\nОдин объект будет весить 6 байт + 24 байта = 30 байт (Приплюсовали дополнительную информацию).\nДля 20 объектов потребуется 20*30 байт = 600 байт.\nОтвет: 600")
def ex12():
    print("Задание 12\nИсполнитель Редактор получает на вход строку цифр и преобразовывает её.\n Редактор может выполнять две команды, в обеих командах v и w обозначают цепочки цифр.\nА) заменить (v, w).\nЭта команда заменяет в строке первое слева вхождение цепочки v на цепочку w. \nНапример, выполнение команды \n   заменить (111, 27)\nпреобразует строку 05111150 в строку 0527150.   \n заменить (v, w) не меняет эту строку.\nБ) нашлось (v).\nЭта команда проверяет, встречается ли цепочка v в строке исполнителя Редактор. \nЕсли она встречается, то команда возвращает логическое значение «истина», \nв противном случае возвращает значение «ложь».\n Строка исполнителя при этом не изменяется.\nЦикл\n    ПОКА условие\n      последовательность команд\n    КОНЕЦ ПОКА\nвыполняется, пока условие истинно.\nВ конструкции \n   ЕСЛИ условие \n     ТО команда1 \n     ИНАЧЕ команда2 \n   КОНЕЦ ЕСЛИ\nвыполняется команда1 (если условие истинно) или команда2 (если условие ложно).\nКакая строка получится в результате применения приведённой ниже программы к строке, состоящей из 70 идущих подряд цифр 8? В ответе запишите полученную строку.\nНАЧАЛО\nПОКА нашлось (2222) ИЛИ нашлось (8888)\n    ЕСЛИ нашлось (2222)\n      ТО заменить (2222, 88)\n      ИНАЧЕ заменить (8888, 22)\n    КОНЕЦ ЕСЛИ\nКОНЕЦ ПОКА\nКОНЕЦ")
    print("Нас интересует вопрос и программа, которые приведены в конце задачи.\n Описание команд, как правило, не меняется от задачи к задаче.\nПереведём программу, написанную на русском языке, на язык программирования Python.")
    print("s = '8'*70\nwhile '2222' in s or '8888' in s:n    if '2222' in s:\n        s = s.replace('2222', '88', 1)\n    else:\n        s = s.replace('8888', '22', 1)\nprint(s)\nВ функции replace() важно не забыть поставить третьим аргументом единицу.\n Это означает, что мы производим замену один раз, а не сразу во всей строке.\nПрограмма распечатает ответ 22.\nОтвет: 22")  
def ex13():
    print("Задание 13\n На рисунке представлена схема дорог, связывающих города А, Б, В, Г, Д, Е, Ж, З, И, К, Л, М. \nПо каждой дороге можно двигаться только в одном направлении, указанном стрелкой.\nСколько существует различных путей из города А в город М, проходящих через город В?")
    print("В начале зачеркнём те стрелки, которые приводят к тому, что мы не пройдём через пункт B.\nПредставляем, что вообще не существует тех стрелок, которые мы зачеркнули.\nСтавим 1 возле начального города А. Смотрим для каждого города, из каких пунктов входят стрелки в конкретный город.\n Суммируем те числа, которые стоят возле тех пунктов, из которых входят стрелки.")
    print("Сначала считаем числа для тех городов, для которых можем это сделать.\nЧисло возле конечного города покажет ответ.\nОтвет: 24")
def ex14():
    print("Задание 14\n начение арифметического выражения\n3*438 + 2*423 + 420 + 3*45 + 2*44 + 1\nзаписали в системе счисления с основанием 16. Сколько значащих нулей содержится в этой записи?")
    print('На слово "значащие" можно не обращать внимание, потому что речь идёт об обычных нулях, которые встречаются в числе.\nНапишем программу на языке Python.\nf=3 * 4**38 + 2 * 4**23 + 4**20 + 3 * 4**5 + 2 * 4**4 + 1\ncount=0\nwhile f>0:\n    d = f % 16\n    if d==0: count=count+1\n    f = f // 16\nprint(count)\nВ первой строчке мы переписываем арифметическое выражение. Две звёздочки подряд обозначают возведение в степень!\nЗатем, заводим переменную count для подсчёта нулей в 16-ричном виде.\nС помощью цикла while, как раз, и получаем все цифры числа f в 16-ричной системе.\nМы смотрим остаток от деления числа f на 16, это и есть очередная цифра в 16-ричной системе (имитируем деление уголком!). Если цифра равна нулю, то её подсчитываем с помощью счётчика count. Так же необходимо сделать целочисленное деление на 16 при каждой итерации.\nВ конце распечатываем переменную count.\nОтвет получился 15.\nОтвет: 15')
def ex15():
    print('Задание 15\nНа числовой прямой даны два отрезка: D = [17; 58] и C = [29; 80].\n Укажите наименьшую возможную длину такого отрезка A, для которого логическое выражение.\n(x ∈ D) → ((¬(x ∈ C) /\ ¬(x ∈ A)) → ¬(x ∈ D))\nистинно (т.е. принимает значение 1) при любом значении переменной х.')
    print('"Главной скрипкой" данного логического выражения является следование, потому что эта операция соединяет различных блоки логические блоки.')
    print('Нам нельзя допустить, чтобы первое выражение принимало 1, а второе 0, одновременно.\nРассмотрим при каких значениях x реализуется этот страшный вариант.\nОпасные значения получаются [17; 29]. Чтобы опасный сценарий нейтрализовать, выражение ¬(x ∈ A)\n должно принимать значение 0. Тогда (x ∈ A) должно выдавать 1.\n Чтобы это происходило всегда при опасных значения, принимаем A=[17, 29]. Длина получается 12.\nОтвет: 12')
def ex16():
    print('Задание 16\nАлгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:\nF(n) = 1 при n = 1;\nF(n) = n + F(n − 1), если n чётно,\nF(n) = 2 × F(n − 2), если n > 1 и при этом n нечётно.\nЧему равно значение функции F(26)?')
    print('Запрограммируем эту задачу на Python`е.\ndef F(n):\n    if n==1: return 1\n    if n%2==0: return n+F(n-1)\n    if n>1 and n%2!=0: return 2*F(n-2)\nprint(F(26))\nФормируем функцию F, в точности, как нам предоставили описание. И запускаем функцию с указанным параметром 26.\nПроверить чётное ли число n или нет, можно, посмотрев остаток от деления n на 2.\nОтвет: 4122')
    otvet16 = int(input("хотите ли проверить решение? если да то введите 1, если нет введите 2: "))
    if otvet16 == 1:
        n = int(input("введите число n : "))
        def F(n):
            if n== 1:
                return 1
            if n%2==0:
                return n+F(n-1)
            if n>1 and n%2!=0:
                return 2*F(n-2)
        print(F(n))
    else:
        print("возвращаю в самое начало для выбора нового задания)")
def ex17():
    print('Задание 17')
    """
    print('1.Стандарт, 5 чисел которые нужно сравнить, минимум или максимум, и количество ')
    print('2.что-то новенькое, 6 чисел которые нужно сравнить, но среди них есть 2 с аргументом or(первые два числа, это важно!)\n 3. так-же 6 чисел но вместо "or" - "and"')
    args1=int(input('Ваше число?: '))
    if args1==2:
        print('Введи числа для поиска, которые нужны в рэнже, это "или"')
        a=int(input('a='))
        b=int(input('b='))
        c=0
        k=0
        print('Введите все числа которые указанны в усливии задачи, последовательно')
        a1 = int(input('число 1, число на которое делить: '))
        a2 = int(input('число 2, которое "или" или "и": '))
        a3 = int(input('число 3: '))
        a4 = int(input('число 4: '))
        a5 = int(input('число 5: '))
        a6 = int(input('число 6: '))
        for i in range(a,b+1):
            if (i%a1==0 or i%a2==0) and i%a3!=0 and i%a4!=0 and i%a5!=0 and i%a6!=0:
                k= k+1
                if i<b:
                    b=i
                if i>c:
                    c=i
        print('кол-во: ' + str(k) +'; min: '+ str(b) +'; max: '+ str(c) +';' )
        print('Введи числа для поиска, которые нужны в рэнже')
    if args1 == 1:
        a=int(input('a='))
        b=int(input('b='))
        c=0

        k=0
        print('Введите все числа которые указанны в усливии задачи, последовательно')
        a1 = int(input('число 1, число на которое делить: '))
        a2 = int(input('число 2: '))
        a3 = int(input('число 3: '))
        a4 = int(input('число 4: '))
        a5 = int(input('число 5: '))
        for i in range(a,b+1):
            if i%a1==0 and i%a2!=0 and i%a3!=0 and i%a4!=0 and i%a5!=0:
                k= k+1
                if i<b:
                    b=i
                if i>b:
                    c=i
        print('кол-во: ' + str(k) +'; min: '+ str(b) +'; max: '+ str(c) +';' )
    if args1 == 3:
        print('Введи числа для поиска, которые нужны в рэнже, это "и"')
        a=int(input('a='))
        b=int(input('b='))
        c=0
        k=0
        print('Введите все числа которые указанны в усливии задачи, последовательно')
        a1 = int(input('число 1, число на которое делить: '))
        a2 = int(input('число 2, которое "или" или "и": '))
        a3 = int(input('число 3: '))
        a4 = int(input('число 4: '))
        a5 = int(input('число 5: '))
        a6 = int(input('число 6: '))
        for i in range(a,b+1):
            if (i%a1==0 and i%a2==0) and i%a3!=0 and i%a4!=0 and i%a5!=0 and i%a6!=0:
                k= k+1
                if i<b:
                    b=i
                if i>c:
                    c=i
        print('кол-во: ' + str(k) +'; min: '+ str(b) +'; max: '+ str(c) +';' )
    print(" a=int(input('a='))\nb=int(input('b='))\nc=0\nk=0\nprint('Введите все числа которые указанны в усливии задачи, последовательно')\na1 = int(input('число 1, число на которое делить: '))\na2 = int(input('число 2, которое \"или\" или \"и\": '))\na3 = int(input('число 3: '))\na4 = int(input('число 4: '))\na5 = int(input('число 5: '))\na6 = int(input('число 6: '))\nfor i in range(a,b+1):\n    if (i%a1==0 or i%a2==0) and i%a3!=0 and i%a4!=0 and i%a5!=0 and i%a6!=0:\n        k= k+1\n        if i<b:\n            b=i\n        if i>c:\n            c=i\nprint('кол-во: ' + str(k) +'; min: '+ str(b) +'; max: '+ str(c) +';' )")
"""
    print("В файле содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от –10 000 до 10 000 включительно. Определите и запишите в ответе сначала количество пар элементов последовательности, в которых хотя бы одно число делится на 3, затем максимальную из сумм элементов таких пар. В данной задаче под парой подразумевается два идущих подряд элемента последовательности. Например, для последовательности из пяти элементов: 6; 2; 9; –3; 6 – ответ: 4 11")
    print("Решим задачу на языке Python. Файл должен быть в той же папке, в которой сохранили программу (или нужно прописать полный путь до файла).")
    print("f=open('17.txt')\n\ncount=0\nsm=0\n\nn1=int(f.readline())\n\nfor s in f.readlines():\n    n2=int(s)\n\n    if n1%3==0 or n2%3==0:\n        count=count+1\n        sm=max(n1+n2, sm)\n    \n    n1=n2\n\nprint(count)\nprint(sm)")
    print("В начале подключаем файл. Заводим переменные count, sm, где будут храниться количество пар и наибольшая сумма.\nСчитываем в n1 из файла первое число для нашей пары. Затем, формируем цикл for, где в переменную s считывается очередная строчка из файла,\n начиная со второй (ведь первая уже считалась в n1). Т.е. n1 - первое число из пары, n2 - второе число из пары.\nПроверяем с помощью условия, делится ли хотя бы одно число из пары на 3. Если да, то прибавляем единицу к счётчику count. Так же, если выполняется условие,\n в переменную sm записывается максимальное значение между старым значением переменной sm и суммой очередной пары.\n Т.е. в переменной sm будет записана максимальная сумма элементов всех пар, которые удовлетворяют условию задачи.\nВ конце цикла кладём значение n2 в переменную n1, и всё повторяется.")
def ex18():
    print("Задание 18")
    print("Квадрат разлинован на N × N клеток (1 < N < 30). Исполнитель Робот может перемещаться по клеткам, выполняя за одно перемещение одну из двух команд: вправо или вниз. По команде вправо Робот перемещается в соседнюю правую клетку, по команде вниз – в соседнюю нижнюю. Квадрат ограничен внешними стенами. Между соседними клетками квадрата также могут быть внутренние стены. Сквозь стену Робот пройти не может. Перед каждым запуском Робота в каждой клетке квадрата лежит монета достоинством от 1 до 100. Посетив клетку, Робот забирает монету с собой; это также относится к начальной и конечной клеткам маршрута Робота. Определите максимальную и минимальную денежные суммы, которые может собрать Робот, пройдя из левой верхней клетки в правую нижнюю. В ответе укажите два числа – сначала максимальную сумму, затем минимальную.Исходные данные представляют собой электронную таблицу размером N × N, каждая ячейка которой соответствует клетке квадрата. Внутренние и внешние стены обозначены утолщенными линиями.Пример входных данных:")
    print("\n1	8	8	4\n10	1	1	3\n1	3	12	2\n2	3	5	6")
    print("ля указанных входных данных ответом должна быть пара чисел\n38	22")
    print('Открываем файл в программе Excel.Выделим все ячейки с числами, нажмём "вырезать", используя контекстное меню. Вставим данные на 1 столбец вправо. Это делаем потому, что будем использовать для решения формулу, которая будет обращаться к ячейке слева.Мысленно представим пространство на 1 строчку ниже, чем область, где находятся числа. Это пространство будет таким же по размерам, как и область с числами. В этом пространстве и будет наше решение')
    print('Отметим особым цветом те ячейки, которые "спрятаны" от движения Робота стенками.')
    print('Для этих ячеек будем составлять другие формулы, в отличии от обычных ячеек.Цвет ячейки можно поменять, нажав на кнопку "Цвет заливки" на главной вкладке программы.Т.к. Робот направляется из левой верхней ячейки, то мы сначала и напишем формулу для этой ячейки. Пишем для ячейки B22:\n=МАКС(B21;A22)+B1\nРобот в любую ячейку может прийти либо сверху, либо слева. Для подсчёта максимального количества монет, мы должны выбрать максимальное предыдущее значение. Это и делаем формула. Плюс Робот должен взять монеты с текущей клетки.Распространим формулу на всё пространство, не трогая закрашенные клетки.')
    print(" ячейки для первой закрашенной области, Робот может попасть только сверху! Поэтому пишем формулу для ячейки H25:\n=H24+H4\nРаспространяем формулу по всему закрашенному столбцу.В ячейки для второй закрашенной области, Робот может попасть только слева! Поэтому пишем формулу для ячейки М39:\n=L39+M18\nРаспространяем формулу по всей закрашенной строчке.В правом нижнем углу нашего рабочего пространства получается максимальное количество монет, которое может собрать Робот. В ячейке U41 получается число 721.Чтобы получить минимальную возможную сумму, в главной формуле функцию МАКС нужно заменить на МИН!Удобно воспользоваться автоматической заменой через Ctrl+F.")
def ex19():
    print("Задание 19")
    print("Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в кучу один камень или увеличить количество камней в куче в два раза. Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней.Игра завершается в тот момент, когда количество камней в куче становится не менее 29. Победителем считается игрок, сделавший последний ход, т.е. первым получивший кучу, в которой будет 29 или больше камней.В начальный момент в куче было S камней, 1 ≤ S ≤ 28.Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника. Описать стратегию игрока – значит описать, какой ход он должен сделать в любой ситуации, которая ему может встретиться при различной игре противника. В описание выигрышной стратегии не следует включать ходы играющего по этой стратегии игрока, не являющиеся для него безусловно выигрышными, т.е. не являющиеся выигрышными независимо от игры противника.Укажите такое значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.")
    print("\n Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в кучу один камень или увеличить количество камней в куче в два раза. Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней.Игра завершается в тот момент, когда количество камней в куче становится не менее 29. Победителем считается игрок, сделавший последний ход, т.е. первым получивший кучу, в которой будет 29 или больше камней.В начальный момент в куче было S камней, 1 ≤ S ≤ 28.Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника. Описать стратегию игрока – значит описать, какой ход он должен сделать в любой ситуации, которая ему может встретиться при различной игре противника. В описание выигрышной стратегии не следует включать ходы играющего по этой стратегии игрока, не являющиеся для него безусловно выигрышными, т.е. не являющиеся выигрышными независимо от игры противника.Укажите такое значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.")
    print("\nНачальная позиция	Ход Пети	Ход Вани	Ход Пети	Ход Вани	Ход Пети\np	1	            2	        3	        4	        5	        6")
    print("\ndef F(x, p):\n    if x>=29 and p==3: return True\n    if x<29 and p==3: return False\n    if x>=29: return False\n\n    if p%2==1:\n        return F(x+1, p+1) and F(x*2, p+1)\n    else:\n         return F(x+1, p+1) or F(x*2, p+1)\n\nfor s in range(1, 29):\n    if F(s, 1):\n        print(s)")
    print("Заводим функцию F. Т.к. у нас одна куча, то она принимает параметры: x - количество камней в куче, p-позиция игры.Дальше описываем победу. Если x>=29 и позиция равна 3 (1 Ход Вани), то возвращаем True, что означает победу.Если, позиция уже равна 3, но камней меньше, чем должно быть для победы, то возвращаем False (проигрыш).Третье условие. Если кто-то выиграл, но на первых двух условиях мы не вышли из функции, то, значит, выиграл не тот, кто нам нужен, следовательно, возвращаем Fasle.Если мы не вышли на первых трёх условиях, то, значит, продолжаем прокручивать ходы, рекурсивно запускаем функцию F.Для нечётных p (это ходы Вани), возвращаем разные ходы через and, т.к. он должен побеждать в любом случае. При этом увеличиваем на 1 значение p.Для чётных p (это ходы Пети), возвращаем ходы через or.В конце перебираем все возможные значения для s через цикл for, ищём те значения, которые подходят по условию задачи.Ответ: 14")
def ex20():
    print("Задание 20")
    print("Для игры, описанной в задании 19, найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:− Петя не может выиграть за один ход;− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.Найденные значения запишите в ответе в порядке возрастания.\n \nРешение:\nЗадача точно такая же, как и в 19 задании, только теперь обязательно должен побежать Петя на своём втором ходу (p=4), при любой игре Вани.Пишем тот же шаблон, немного отредактировав его.\ndef F(x, p):\n    if x>=29 and p==4: return True\n    if x<29 and p==4: return False\n    if x>=29: return False\n\n    if p%2==0:\n        return F(x+1, p+1) and F(x*2, p+1)\n    else:\n         return F(x+1, p+1) or F(x*2, p+1)\n\nfor s in range(1, 29):\n    if F(s, 1):\n        print(s)\n\nПолучается 7 и 13.\nОтвет:\n7	13")
def ex21():
    print("Задание 21")
    print("Для игры, описанной в задании 19, найдите значение S, при котором одновременно выполняются два условия:− у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;− у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.Если найдено несколько значений S, в ответе запишите минимальное из них.\nРешение:Опять используем прошлый шаблон, но немного модернизируем.\ndef F(x, p):\n    if x>=29 and (p==3 or p==5): return True\n    if x<29 and p==5: return False\n    if x>=29: return False\n\n    if p%2==1:\n        return F(x+1, p+1) and F(x*2, p+1)\n    else:\n         return F(x+1, p+1) or F(x*2, p+1)\n\ndef F1(x, p):\n    if x>=29 and p==3: return True\n    if x<29 and p==3: return False\n    if x>=29: return False\n\n    if p%2==1:\n        return F1(x+1, p+1) and F1(x*2, p+1)\n    else:\n         return F1(x+1, p+1) or F1(x*2, p+1)\n\nfor s in range(1, 29):\n    if F(s, 1):\n        print(s)\n\nprint()\n\nfor s in range(1, 29):\n    if F1(s, 1):\n        print(s)Здесь Ваня должен выигрывать либо на первом своём ходе (p=3), либо на втором своём ходе (p=5).Т.к. Ваня не должен гарантированно выиграть своим первым ходом, то мы создаём ещё одну функцию F1, похожую на основную функцию F, которая вычисляет, когда Ваня именно гарантированно выигрывает на своём первом ходе (p=3). И, затем, мы из тех чисел, которые получились в первой функции F, исключаем числа, которые получились во второй функции F1.В первой функции получилось 12,14, а во второй 14. Получается ответ 12.\nОтвет: 12")
def ex22():
    print("Задание 22")
    print("Ниже на четырёх языках программирования записан алгоритм. Получив на вход число x, этот алгоритм печатает два числа: L и M. Укажите наибольшее число x, при вводе которого алгоритм печатает сначала 4, а потом 5.")
    print("Python\n x = int(input())\nQ= 9 \n L=0\nwhile x>=Q:\n    L=L+1\n     x=x-Q\nM=x\nif M<L:\n   M=L\n   L=x\nprint(L)\nprint(M)")
    print("Решение данного задания будет похоже на решение 6 задания из ЕГЭ по информатике 2022.С помощью перебора на языке Python найдём при каких значениях переменная L=4 И переменная M=5 в конце программы.")
    print("Решение: \n for i in range(1, 1000):\nX=i\nQ=9\nL=0\nwhile X >= Q:\n    L = L + 1\n    X = X - Q\nM=X\nif M < L:\n    M = L\n    L = X\nif L==4 and M==5: print(i)")
def ex23():
    print("Задание 23")
    print("Исполнитель преобразует число на экране.У исполнителя есть две команды, которым присвоены номера:      \n1. Прибавить 1  \n2. Умножить на 2Программа для исполнителя – это последовательность команд. Сколько существует программ, для которых при исходном числе 1 результатом является число 20, и при этом траектория вычислений содержит число 10?Траектория вычислений программы – это последовательность результатов выполнения всех команд программы. Например, для программы 121 при исходном числе 7 траектория будет состоять из чисел 8, 16, 17.")
    print("Решим задачу c помощью шаблона на языке Python.\ndef F(x, y):\n    if x == y: return 1\n\n    if x > y: return 0\n\n    if x < y: return F(x+1, y) + F(x*2, y)\nprint(F(1, 10)*F(10, 20))Число x, это то число, с которым мы работаем. Число y - это куда нужно прийти.Если число x достигло пункта назначения, то возвращаем 1. Если оно перескочило y, то возвращаем 0. А если ещё не дошло до y, то продолжаем вычисления с помощью рекурсии.У нас число 10 обязательное, поэтому разбиваем функцию следующим образом F(1, 10)*F(10, 20), через умножение. Это и будет ответ. Получается 28.")
def ex24():
    print("Задание 24")
    print("Текстовый файл состоит из символов P, Q, R и S.Определите максимальное количество идущих подряд символов в прилагаемом файле, среди которых нет идущих подряд символов P. Для выполнения этого задания следует написать программу.")
    print("Напишем решение на языке Python.\n\n\nf=open('24.txt')\ns=f.read()\ncount=1\nmx=0\n\nfor i in range(0, len(s)-1):\n    if s[i]=='P' and s[i+1]=='P':\n        count=1\n    else:\n        count=count+1\n        mx = max(mx, count)\n\nprint(mx)\nПодсчитываем символы, пока не встретилась комбинация двух P подряд. Как только встретилась данная комбинация, сбрасываем счётчик на 1. Здесь мы сбрасываем счётчик на значение 1, чтобы учесть один символ, которые находится в самой комбинации PP. И в начале мы тоже устанавливаем счётчик в значение 1 по этой же причине")
    print("Мы проходим в цикле for до длины строки минус один. Значение 1 в счётчике при сбросе и в начале программы так же компенсирует и тот момент, что мы не подсчитываем последний символ!При изменении счётчика, сохраняем максимальное значение в переменной mxЕсли бы у нас была вместо PP другая комбинация, состоящая к примеру из 5 символов, то мы бы тогда в начале и при сбросе писали в счётчик значение 5-1=4.В этой задаче получается ответ 188.")
def ex25():
    print("Задание 25")
    print("Пусть M – сумма минимального и максимального натуральных делителей целого числа, не считая единицы и самого числа. Если таких делителей у числа нет, то значение M считается равным нулю.Напишите программу, которая перебирает целые числа, бо́льшие 700 000, в порядке возрастания и ищет среди них такие, для которых значение M оканчивается на 8. Выведите первые пять найденных чисел и соответствующие им значения M.Формат вывода: для каждого из пяти таких найденных чисел в отдельной строке сначала выводится само число, затем – значение М. Строки выводятся в порядке возрастания найденных чисел.Количество строк в таблице для ответа избыточно.На ЕГЭ по информатике 2022 удобно писать программы на языке Python.\nimport math\ncount=0\nfor i in range(700001, 800000):\n\n    b=0\n    \n    for j in range(2, int(math.sqrt(i)) + 1):\n        if i%j==0:\n            b=round(i/j)\n            break\n    \n    \n    if  b==0: M=0\n    else: M=j+b\n\n    if M!=0 and M%10==8:\n        count=count+1\n        print(i, M)\n\n    if count==5: breakВ данной программе перебираются числа в цикле for, начиная с 700001.Переменная b-считается наибольшим делителем числа i. Затем, с помощью ещё одного цикла for перебираются числа с 2 до корня числа i (включительно). Ищем тем самым наименьший делитель.Если до корня числа включительно не встретился ни один делитель, значит, у числа нет делителей, кроме 1 и самого числа.Пусть у нас есть число A. Если у этого числа есть делитель d1, то он находится до корня этого числа. А вот то число (так же делитель), на которое умножается это число d1, чтобы получить A, будет находиться после корня A.Получается, что у каждого делителя есть своя пара. У единицы - это само число. Причём один делитель из пары находится до корня, другой после корня. Исключением будет тот случай, когда из числа А извлекается целый корень. Тогда для этого корня не будет пары (парой и будет само это число √A * √A = A).Таким образом, первый найденный делитель будет являться наименьшим делителем. А вот делительный, который находится в паре с наименьшим делителем, будет наибольшим.После того, как мы нашли наименьший делитель (он будет сидеть в переменной j) и наибольший делитель b, выходим из второго цикла for.Если переменная b осталась равна нулю, то, значит, у числа i нет указанных делителей, и переменная M должна равняться 0. Если b не равна нулю, то M=j+b.Проверить, на что оканчивается число, можно узнав остаток от деления числа на 10.Переменная count следит, чтобы было распечатано ровно 5 чисел, которые удовлетворяют условию задачи.")
def ex26():
    print("Задание 26")
    print("cистемный администратор раз в неделю создаёт архив пользовательских файлов. Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов.Известно, какой объём занимает файл каждого пользователя.По заданной информации об объёме файлов пользователей и свободном объёме на архивном диске определите максимальное число пользователей, чьи файлы можно сохранить в архиве, а также максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей.Входные данные.В первой строке входного файла находятся два числа: S – размер свободного места на диске (натуральное число, не превышающее 10 000) и N – количество пользователей (натуральное число, не превышающее 1000). В следующих N строках находятся значения объёмов файлов каждого пользователя (все числа натуральные, не превышающие 100), каждое – в отдельной строке.Запишите в ответе два числа: сначала наибольшее число пользователей, чьи файлы могут быть помещены в архив, затем – максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей.Пример входного файла:\n100 4\n80\n30\n50\n40При таких исходных данных можно сохранить файлы максимум двух пользователей. Возможные объёмы этих двух файлов – 30 и 40, 30 и 50 или 40 и 50. Наибольший объём файла из перечисленных пар – 50, поэтому ответ для приведённого примера:2 50\nРешим задачу с помощью Excel. Чтобы открыть текстовый файл в программе Excel, выбираем Файл->Открыть, выбираем нужную папку и указываем, чтобы в папке были видны все типы файлов.И выбираем наш текстовый файл.Выскочит окно Мастер текстов (импорт). Здесь оставляем выбранный пункт с разделителями и кликаем Далее.В следующем окне поставим ещё галочку пробел. В итоге Символами-разделителем будут знак табуляции и пробел.Кликаем ещё раз Далее и Готово.Наши данные вставятся, как нужно!Число 8200 (размер свободного места) нужно запомнить или записать на черновике. Число 970 (количество файлов) нам в принципе не нужно при таком подходе решения.Теперь удаляем первую строчку. Выделяем две ячейки в первой строчке, через контекстное меню мыши нажимаем Удалить.... Выбираем ячейки, со сдвигом вверх.1. Найдём максимальное количество файлов.Выделяем весь столбец A и сортируем его по возрастанию.Теперь выделяем ячейки сверху мышкой, а справа в нижней части программы будет показываться сумма выделенных ячеек.Мы должны выделить максимальное количество ячеек, но чтобы сумма не превышала число 8200.Получается максимальное количество файлов, которое можно сохранить, равно 568.2. Найдём максимальный размер файла при максимальном количестве файлов.Если мы сохраним максимальное количество файлов, то у нас ещё останется свободное место 8200-8176=24, т.к. сумма выделенных ячеек равна 8176.Мы можем заменить наибольший файл (последняя выделенная ячейка равная 29) ещё большим файлом, размер которого не превышает 24+29=53.Если покрутим таблицу вниз, то найдём такой файл размером 50. Это и будет наибольший файл при максимальном количестве файлов.")
def ex27():
    print("Задание 27")
    print('На вход программы поступает последовательность из целых положительных чисел. Необходимо выбрать такую подпоследовательность подряд идущих чисел, чтобы их сумма была максимальной и делилась на 89, а также её длину. Если таких подпоследовательностей несколько, выбрать такую, у которой длина меньше.Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество чисел N (2 ≤ N ≤ 68000). В каждой из последующих N строк записано одно целое положительное число, не превышающее 10000. Программа должна вывести длину найденной последовательности.Пример входного файла:\n8\n2\n3\n4\n93\n42\n34\n5\n95Для делителя 50 при указанных входных данных значением искомой суммы должно быть число 100 (3 + 4 + 93 или 5 + 95). Следовательно, ответ на задачу — 2. В ответе укажите два числа: сначала значение искомой суммы для файла A, затем для файла B.Т.е. мы должны найти длину цепочки элементов, чтобы их сумма была самая большая из всех возможных, и при этом делилась на 89.Напишем код на Python.\nf=open("27_B.txt")\n#Считываем количество чисел\nn=int(f.readline())\nsm=0\na=[]\n#Записываем все числа в массив\n#Cуммируем все элементы в sm\nfor i in range(1, n+1):\n    x=int(f.readline())\n    a.append(x)\n    sm=sm+x\n#Найдём количество "лишних" единиц.\nlishnie_edinici = sm % 89\n#Количество элементов, которые нужно отнять от всей суммы\ncount=0\n################# 1 Эпизод #################\nsm1 = 0\nk1=0\nfor i in range(0, n):\n    sm1=sm1+a[i]\n    k1=k1+1\n    if sm1%89==lishnie_edinici:\n        break\n################# 2 Эпизод #################\nsm2=0\nk2=0\nfor i in range(n-1, -1, -1):\n    sm2=sm2+a[i]\n    k2=k2+1\n    if sm2%89==lishnie_edinici:\n        break\n################# 3 Эпизод #################\nif sm1 < sm2:\n    mn=sm1\n    count=k1\nelse:\n    mn=sm2\n    count=k2\n\nif sm1==sm2:\n    count=max(k1, k2)\nsm3_1=0\nk3_1=0\nk3_2=0\nfor i in range(0, n):\n    if sm3_1 > mn: break\n    sm3_1=sm3_1+a[i]\n    k3_1=k3_1+1\n\n    k3_2=0\n    sm3_2=0\n    for j in range(n-1, -1, -1):\n        sm3_2=sm3_2+a[j]\n        k3_2=k3_2+1\n        if (sm3_1+sm3_2)%89==lishnie_edinici:\n            if (sm3_1+sm3_2) < mn:\n                mn=sm3_1+sm3_2\n                count=k3_1+k3_2\n\n            if sm3_1+sm3_2==mn:\n                count=max(count, k3_1+k3_2)\n            \n            break\n################# 4 Эпизод #################\nsm4_1=0\nk4_1=0\nk4_2=0\nfor i in range(n-1, -1, -1):\n    if sm4_1 > mn: break\n    sm4_1=sm4_1+a[i]\n    k4_1=k4_1+1\n\n    k4_2=0\n    sm4_2=\n\n\n    for j in range(0, n):\n        sm4_2=sm4_2+a[j]\n        k4_2=k4_2+1\n        if (sm4_1+sm4_2)%89==lishnie_edinici:\n            if (sm4_1+sm4_2) < mn:\n                mn=sm4_1+sm4_2\n                count=k4_1+k4_2\n\n            if sm4_1+sm4_2==mn:\n                count=max(count, k4_1+k4_2)\n\n            break\n#Распечатываем ответ\nif lishnie_edinici==0:\n    print(n)\nelse:\n    print(n-count)В начале мы суммируем все числа в переменную sm. Это и есть самая большая сумма, которую мы можем получить. Но наша сумма так же должна делится на число 89.Узнаем, а что мешает нашей сумме делиться на 89. Т.е. узнаем, сколько "лишних" единиц в этой сумме. Для этого найдём остаток от деления суммы на 89 и занесём результат в переменную lishnie_edinici.Теперь наша задача сводится к тому, чтобы убрать эти "лишние" единицы, и как можно меньше "навредить" уже найденной сумме (Т.е. чтобы сумма осталось максимальной).')
    print('1 Эпизод. Смотрим, сколько нужно "снять" элементов сверху из нашей цепочки, чтобы сумма снятых элементов содержала в себе нужно количество "лишних" единиц.Как только мы это найдём, в переменной sm1 будет сумма элементов, которые можно снять сверху, чтобы сумма основной цепочки делилась на 89. В переменной k1 будет количество этих элементов.2 Эпизод. Всё аналогично первому эпизоду, только пробуем снять элементы снизу основной цепочки.3 Эпизод. Нам нужно убрать элементы, у которых сумма будет как можно меньше, ведь в основной цепочке сумма должна быть, как можно больше! После двух эпизодов мы кладём наименьшую сумму убранных элементов в переменную mn.Мы можем снимать элементы и сверху, и снизу одновременно. Берём сначала один элемент сверху, а остальные снизу. Как только в сумме убранных элементов накопились "лишние" единицы, проверяем, может этот результат и будет претендовать на ответ? Т.е. сравниваем сумму убранных элементов с переменной mn.Если сумма больше, чем переменная mn, то она нас не интересует. Тогда берём два элемента сверху, а остальные снизу и продолжаем.Если сумма убранных элементов меньше (и там есть нужное количество "лишних" единиц), то это значение перезаписывается в mn.Затем, мы продолжаем третий эпизод до тех пор, пока сумма элементов, которые мы берём сверху, не превысит переменную mn. Ведь, если эта сумма превысит переменную mn, то мы точно не получим сумму убранных элементов меньшую, чем уже имеющийся результат.4 Эпизод. Делаем аналогично 3 эпизоду, только верх и низ меняем местами.Во всех эпизодах учитываем, что, если сумма убранных элементов равна значению переменной mn, мы должны выбрать тот вариант, где количество убранных элементов, как можно больше, ведь нам нужна основная цепочка с наименьшим количеством элементов.После того, как у нас выберется самый лучший вариант, мы должны от общего числа элементов отнять количество убранных элементов.Ответ: Файл А: 159, Файл Б: 67059')









